# JSON → TypeScript 변환기 심층 분석 (한국어 정리)

## 1. 주요 도구 개관

이번에 비교한 대표적인 JSON → TypeScript 변환기는 다음 세 가지입니다.

- **Transform.tools** 의 JSON → TypeScript 변환기
- **Quicktype** (app.quicktype.io 웹 앱 + CLI)
- **JSON Crack** (jsoncrack.com)

각 도구가 어떤 방식으로 타입을 생성하는지, 어떤 한계가 있는지, 그리고 사용자 피드백에서 반복적으로 등장하는 요구사항이 무엇인지 정리합니다.

---

## 2. 기능 비교 – 도구별 동작 방식

### 2-1. 핵심 기능 비교 표

| 기능 항목                          | Transform.tools (JSON→TS)                                                                                 | Quicktype (웹/CLI)                                                                                                             | JSON Crack (jsoncrack.com)                                                                 |
|------------------------------------|------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------|
| **출력 타입 스타일**               | 기본적으로 객체는 항상 **interface**로 생성. `type` alias 선택 옵션 없음.                               | 기본은 **interface** + 선택적으로 JSON 파싱/검증용 헬퍼 코드(클래스) 생성. `type` alias로 바꾸는 설정은 별도로 없음.      | **interface**만 생성. `type` alias 선택 옵션 없음.                                        |
| **optional(`?`) 처리**             | 샘플 JSON 1개 기준. 존재하는 키는 모두 **필수(required)**로 처리. optional 제어 옵션 거의 없음.          | 여러 샘플을 주면 필드 존재 여부를 보고 optional 추론 가능. CLI에 `--all-properties-optional` 플래그 등 존재.             | 샘플 1개 기준으로 모든 키를 필수로 처리. multiple sample 기반 optional 추론 기능 없음.    |
| **`null` 처리 방식**              | `null` 값은 타입에서 `| null`로 그대로 포함. `null`을 optional로 해석하는 모드 없음.                     | 값이 null일 수 있으면 `타입 | null` 형식으로 union에 포함. `null → optional` 변환은 자동 지원하지 않음.                   | 마찬가지로 `null`을 union에 포함 (`타입 | null`). optional로 바꾸는 옵션 없음.            |
| **배열(혼합 타입) 처리**           | 과거에는 혼합 배열에서 `any`로 떨어지거나, 객체 shape가 다르면 interface 다수 + union 남발 문제가 있었음. | 혼합 primitive 배열은 `(A \| B)[]` 등 union 타입으로 처리. 객체 shape가 다른 경우도 최대한 합치거나, 깔끔한 union 생성. | 혼합 배열에 대해 union 타입 생성은 하지만, 객체 구조가 조금만 달라도 interface가 난립하는 경향. |
| **문자열 리터럴 / enum 추론**      | 문자열은 전부 `string`으로 처리. enum/리터럴 union 자동 생성 없음.                                       | 여러 샘플/스키마 기반으로 enum 또는 `"a" \| "b"` 형태 리터럴 union 생성 가능. enum 대신 union을 쓰는 옵션도 있음.        | 문자열은 항상 `string`. enum이나 리터럴 union 타입 생성 없음.                             |
| **중첩 객체 처리**                | 중첩 객체를 별도 interface로 분리. 키 이름 기반으로 타입 이름을 짓지만, 네이밍 커스터마이즈는 제한적.    | 중첩 객체를 별도 interface로 분리하고, 이름 충돌 시 자동 조정. 비슷한 객체를 합칠지 말지 제어하는 플래그도 존재.        | 키 이름 기반으로 인터페이스 이름 생성. 네이밍 커스터마이즈는 거의 없음.                   |
| **런타임 코드(파서/검증) 생성**    | TypeScript 타입/인터페이스만 생성. 런타임 파서나 검증 함수는 생성하지 않음.                              | 타입 + JSON 파싱/검증용 헬퍼 코드(예: `Convert.fromJson`)를 같이 생성 가능. 원하면 “타입만 생성” 모드도 선택 가능.      | 타입 정의만 생성. 런타임 검증/파서 코드는 없음.                                           |
| **입력 포맷**                      | 이 모드에서는 순수 JSON만 입력. 다른 포맷은 별도 변환기에 존재.                                          | JSON, JSON Schema, GraphQL 스키마, URL/디렉터리 등 다양한 입력 지원. 실제 워크플로에 유리.                               | JSON 외에도 YAML, CSV, XML, TOML 등을 JSON으로 바꿔 타입 생성. JSON Schema 입력은 X.     |
| **UI/UX & 커스터마이즈 수준**      | 웹 에디터 좌/우 구조. JSON→TS 모드에서는 옵션 거의 없음. interface vs type, optional 전략 등 고정.      | 웹 UI에 일부 설정(런타임 코드 포함 여부, enum vs union 등) + CLI에 매우 다양한 플래그. VSCode 확장과 통합 사용 가능.    | JSON 시각화에 초점. 타입 생성은 부가 기능 수준으로, 출력 스타일 커스터마이즈는 거의 없음. |

---

## 3. 사용자 피드백과 공통적으로 나오는 요구사항

GitHub 이슈, Reddit, Hacker News, Dev.to 등에서 반복적으로 나온 피드백/요청들을 정리하면 다음과 같습니다.

### 3-1. interface 대신 type alias 를 쓰고 싶다

- 여러 도구에서 공통적으로 나오는 요구입니다.
- 특히 Transform.tools 쪽에는 “interface 말고 `type` alias로 출력해 달라”는 이슈가 실제로 존재합니다.
- 이유:
  - 코드 스타일 취향 문제 (팀 컨벤션이 `type` 선호인 경우).
  - interface는 같은 이름으로 중복 선언될 경우 자동으로 병합되는 TypeScript 특성이 있어서, 이를 피하려는 경우도 있음.

### 3-2. optional vs required를 더 잘 제어하고 싶다

- 단일 JSON 샘플만 보면 “어떤 필드는 사실 optional이어야 한다”는 정보를 알 수 없어서, 도구들은 기본적으로 **존재하는 필드는 전부 필수**로 처리합니다.
- 실제 API 스펙에서는 optional 필드가 많기 때문에, 사용자들은:
  - UI에서 필드별로 optional을 켜고 끌 수 있는 기능,
  - 혹은 null/빈값 등으로 optional 여부를 추론하는 설정
  - 여러 샘플을 쓰지 않아도 optional을 어느 정도 제어할 수 있는 옵션
  을 원합니다.
- Quicktype은 “여러 샘플을 주라”는 식으로 가이드를 하지만, 현실적으로 번거롭다는 의견이 많습니다.

### 3-3. union 타입이 과도하게 많아지는 문제

- 배열 안에 객체 구조가 조금씩 다른 경우, 인터페이스 여러 개를 만들고 그것들을 union으로 묶는 방식은 매우 안전하지만, 사람이 보기에는 타입 정의가 지나치게 복잡해집니다.
- 많은 개발자가 “차라리 하나의 인터페이스로 합치고, 필드를 optional로 만드는 쪽이 낫다”고 느낍니다.
- 그래서 “object shape union을 자동으로 합쳐서 superset 타입 하나 + optional 필드 형태로 만들어 달라”는 요구가 상당히 많습니다.
- 특히 Transform.tools에서 이 문제에 대한 이슈가 자주 언급되었고, Quicktype도 옵션을 통해 타입 통합 여부를 제어하고 있습니다.

### 3-4. `any`를 최대한 쓰지 말아 달라

- 대부분의 개발자는 `any`를 싫어합니다.
- JSON 구조가 복잡하거나, 타입 정보가 부족한 경우 일부 도구는 쉽게 `any`로 떨어져 버리는 경우가 있었고, 이게 불만의 큰 원인입니다.
- 사용자들은 “`any` 대신 가능한 한 union, `unknown`, 더 구체적인 타입을 써 달라”고 요청합니다.

### 3-5. `null`을 optional처럼 해석하는 옵션

- 현재 도구들은 `null` 값을 발견하면 대부분 `타입 | null`로 타입에 포함시킵니다.
- 하지만 많은 API는 “값 없음”을 null로 내려주는 패턴을 쓰기 때문에, 개발자들은 “이건 사실 optional로 보는 게 더 자연스럽다”고 느끼는 경우가 많습니다.
- 그래서:
  - JSON에 null이 포함된 필드를 optional 프로퍼티(`?`)로 만들고,
  - 타입 union에서는 null을 빼버리는 모드
  를 원한다는 피드백이 꽤 있습니다.

### 3-6. 문자열 리터럴 타입 추론

- Quicktype은 여러 샘플이나 JSON Schema 기반으로 enum/리터럴 타입을 잘 추론하지만,
- 단일 샘플에서는 문자열을 대체로 그냥 `string`으로 처리합니다.
- 고급 사용자들은:
  - `"mode": "dark"` 같은 필드를 `"dark"` 리터럴로 만들어 주거나,
  - `"status": "active"` / `"inactive"` 같은 패턴을 자동으로 `"active" | "inactive"`와 같은 union으로 제안해 주는 기능
  을 원하기도 합니다.
- 잘못 추론하면 타입이 과하게 좁아질 수 있어 기본값으로 활성화하기는 부담스럽지만, 고급 옵션으로 원하는 수요가 존재합니다.

### 3-7. 네이밍 컨벤션 자동 변환

- JSON 키는 snake_case, TS 코드에서는 camelCase로 쓰고 싶은 경우가 많습니다.
- Quicktype CLI는 이에 대한 옵션(`--nice-property-names` 등)이 있지만,
- 웹 기반 도구들에서는 이런 설정이 없거나 제한적입니다.
- “프로퍼티 이름을 자동으로 camelCase로 바꾸고, 원본 JSON과의 매핑도 함께 생성해 달라”는 요구가 종종 보입니다.

### 3-8. 큰 JSON 에 대한 성능 및 UX 문제

- JSON이 지나치게 크면 웹 에디터가 버벅거리거나 브라우저가 멈추는 문제 보고가 있습니다.
- JSON Crack의 FAQ에도 큰 JSON은 시각화에 시간이 걸린다는 경고가 있을 정도입니다.
- 요청되는 개선 사항:
  - 파일 업로드 지원
  - 상위 몇 레벨만 샘플링해서 타입을 생성하는 모드
  - 처리 시간 안내/경고 등

### 3-9. 사용자 설정 기억하기

- 웹 도구는 기본적으로 매번 초기 설정으로 리셋되는 경우가 많습니다.
- Quicktype 웹 앱도 런타임 코드 포함 여부, enum vs union 등 설정을 매번 다시 눌러야 해서 불편하다는 의견이 있습니다.
- 브라우저 로컬 스토리지 등에 사용자의 선호 설정을 기억해 두었다가, 다음 방문 시에도 그대로 적용해 주길 바라는 피드백이 존재합니다.

### 3-10. 복잡한 스키마 처리 버그

- JSON Schema의 `allOf`, `oneOf`, `anyOf` 같은 조합을 정확히 처리하지 못하는 이슈,
- 특정 변환에서 구조를 잘못 읽는 버그,
- 에러 메시지가 불명확한 문제
  등이 각 도구별로 보고되어 있습니다.
- 전체적으로 보면 “JSON Schema 기능을 더 폭넓고 정확하게 지원해 달라”, “실패할 때 더 이해하기 쉬운 에러를 보여 달라”는 방향의 요구입니다.

---

## 4. 여기서 뽑을 수 있는 차별화 포인트 (우선순위 포함)

위의 도구들과 사용자 피드백을 바탕으로, 새로운 JSON → TypeScript 변환기에서 노릴 수 있는 차별화 포인트를 우선순위와 함께 정리하면 다음과 같습니다.

### 4-1. (우선순위 ★★★★★) `null → optional` 모드

- `null` 값을 발견했을 때 타입에 `| null`을 추가하는 대신,
  - 해당 필드를 optional(`?`)로 전환하고,
  - union 타입에서는 `null`을 제거하는 모드.
- 예) `{ "name": null }` →  
  - 기본 모드: `name: string | null;`  
  - `null → optional` 모드: `name?: string;`
- 간단한 글로벌 토글만 있어도, 기존 도구들이 지원하지 못한 “개발자 감각에 맞는 타입 생성”을 제공 가능.

### 4-2. (우선순위 ★★★★★) union 타입 자동 병합 (superset 타입 생성)

- 배열 안에 서로 조금씩 다른 객체들이 들어 있는 경우,
  - 인터페이스 여러 개 + 길고 복잡한 union 타입 대신,
  - 가능한 한 **하나의 superset 인터페이스 + optional 필드**로 합치기.
- 예)
  - `{ a: 1 }`  
  - `{ a: 2, b: "x" }`
- 나쁜 예: `Array< { a: number } | { a: number; b: string } >`
- 좋은 예: `Array<{ a: number; b?: string }>`
- 기본값을 “합치는 쪽”으로 두고, 옵션으로 “정확한 union 유지 모드(합치지 않음)”도 제공하면, 대부분의 사용자에게 더 읽기 좋은 타입을 제공할 수 있음.

### 4-3. (우선순위 ★★★★★) UI 상에서 타입을 직접 손보는 인터랙티브 편집 기능

- “입력 → 고정된 출력”이 아니라, 출력된 타입을 UI에서 바로 조정할 수 있도록:
  - 필드별 optional on/off 토글
  - 필드 이름/타입 이름 변경 시 관련 참조 자동 갱신
  - 사용하지 않을 필드 체크해서 제외
  - 상위 타입을 interface ↔ type alias 로 전환
- 이렇게 하면:
  - 자동 생성이 80~90%까지 해주고,
  - 나머지 10~20%를 UI에서 정리한 다음 최종 코드만 복사해 가는 워크플로를 제공 가능.
- 기존 도구보다 “실제 프로젝트에 곧장 가져다 쓰기 좋은 결과”를 만들어줄 수 있는 큰 차별점.

### 4-4. (우선순위 ★★★★☆) 문자열 리터럴 union / enum 고급 추론

- 여러 샘플을 입력받아, 특정 문자열 필드에 대해 가능한 값 목록을 모은 뒤:
  - `"foo" | "bar" | "baz"` 형태의 리터럴 union 타입,
  - 혹은 enum 타입을 생성.
- (옵션으로) 단일 샘플이라도 특정 패턴이면 “리터럴 타입 후보”로 제안:
  - 예: `"mode": "dark"` → “`"dark"` 리터럴 타입으로 만들까요?” 팝업/옵션.
- 이 기능은 기본적으로 꺼 두고, **고급 모드**에서만 켜도 충분히 매력적인 차별 포인트.

### 4-5. (우선순위 ★★★★☆) 타입 + 런타임 검증/스키마 동시 생성

- 단순히 interface/type만 내보내는 게 아니라,
  - Zod 스키마
  - io-ts codec
  - 혹은 간단한 런타임 체크 함수
  를 함께 생성하는 모드.
- 예: “TS 타입 + Zod 스키마를 함께 생성” 버튼.
- 개발자는 타입 안전성과 런타임 검증을 한 번에 구성할 수 있어 큰 편의성 제공.
- Transform.tools는 Zod/io-ts 변환기가 따로 존재하지만, “한 번에 같이 생성”하는 UX로 차별화할 수 있음.

### 4-6. (우선순위 ★★★★☆) 프로퍼티 네이밍 컨벤션 변환 (snake → camel 등)

- JSON 키는 snake_case, TS 코드에서는 camelCase로 쓰고 싶은 경우:
  - 출력 인터페이스의 프로퍼티 이름을 camelCase로 자동 변환,
  - 필요 시 원본 키와의 매핑 코드(예: 매핑 함수, Zod transform 등) 생성.
- Quicktype CLI에도 비슷한 기능이 있지만,
  - 웹 UI 상에서 직관적인 토글과 매핑 코드까지 함께 보여주는 경험은 아직 부족.
- 데이터 핸들링 코드가 많은 프로젝트에서 상당한 장점이 될 수 있음.

### 4-7. (우선순위 ★★☆☆☆) 다중 언어 타입 번들

- 부가 기능으로, 한 번 JSON을 넣으면:
  - TypeScript 타입
  - Python dataclass
  - Go struct
  등을 탭으로 전환해서 보여주는 모드.
- Quicktype도 여러 언어를 지원하지만, 보통 한 번에 하나 선택.
- “여러 언어용 타입을 동시에 생성하는 툴”은 크로스 스택 개발자에게 매력적인 포인트가 될 수 있음.

### 4-8. (우선순위 ★★☆☆☆) 큰 JSON에 대한 성능/UX 배려

- 대형 JSON 입력에 대해:
  - 파일 업로드 지원
  - 상위 몇 레벨만 샘플링하여 타입 생성
  - 처리 시간/경고 표시
- 단순하지만, 실제 대형 응답(JSON)을 다루는 API 개발자에게는 체감상 큰 차이.

### 4-9. (우선순위 ★★☆☆☆) 설정 저장 / 공유 기능

- 브라우저 로컬 스토리지 등에 사용자 설정(예: interface vs type, null 처리 모드, naming 규칙 등)을 저장.
- “현재 JSON + 설정 + 결과”를 링크로 공유할 수 있게 해, 팀원이 그대로 열어볼 수 있도록 하는 기능.
- 장기적으로 자주 사용하는 사용자에게 “쓸수록 편해지는 도구”라는 인상을 줄 수 있음.

---

## 5. 결론

정리하면, 현재 인기 있는 JSON → TypeScript 변환기(Transform.tools, Quicktype, JSON Crack 등)는 공통적으로:

- **interface 강제**
- **optional/nullable 제어 부족**
- **union 타입 과다 생성**
- **any로 쉽게 떨어지는 케이스**
- **문자열 리터럴/enum 추론의 제약**
- **네이밍/스타일 커스터마이즈 부족**

이라는 한계를 가지고 있습니다.

새로운 도구를 만든다면, 특히 다음 네 가지를 우선 공격하는 것이 가장 강력한 차별화 포인트가 될 수 있습니다.

1. `null → optional` 모드  
2. union 타입 자동 병합(한 개의 superset 타입으로 정리)  
3. UI에서 타입을 직접 손볼 수 있는 인터랙티브 편집 기능  
4. 문자열 리터럴 union / Zod 등과의 통합 같은 고급 타입 지원  

이렇게 하면 “그냥 JSON을 TypeScript로 바꿔주는 변환기 하나 더”가 아니라,  
**“실제 프로젝트에서 매일 써도 아깝지 않은 타입/스키마 워크벤치”**에 가깝게 만들 수 있습니다.
